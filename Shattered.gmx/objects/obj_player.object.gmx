<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>player_idle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize Variables
depth = -1000;

grav = 1;
hsp = 0;
vsp = 0;
max_vsp = 15;
jumpsp = 20;
movesp = 8;

grounded = false;
grab = 0;
choosing = false;

sprite_state = 0; //0 - idle | 1 - running | 2 - jumping | 3 - falling
last_state = sprite_state;

climbing_ladder = false;
attacking = false;
talking = false;

first_xscale = image_xscale;

image_speed = image_number / room_speed;

//number of collectibles you picked
keys = 0;

//this global variable will be used to destroy the arrows that have been thrown if the is more than a certain treshold
MAX_ARROWS = 10;
number_of_arrows = MAX_ARROWS;

gmwRegisterObject(id, "player", global.DEFAULT_GROUP);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Input

key_right = keyboard_check(ord("D"));
key_left = -keyboard_check(ord("A"));
key_up_pressed = keyboard_check_pressed(ord("W"));
key_down_pressed = keyboard_check_pressed(ord("S"));
key_up = keyboard_check(ord("W"));
key_down = keyboard_check(ord("S"));
key_jump = keyboard_check_pressed(vk_space);
key_attack = keyboard_check(ord("F"));
key_interact = keyboard_check_pressed(ord("E"));
key_grab = keyboard_check_pressed(ord("G"));
mouse_left = mouse_check_button_pressed(mb_left);



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement &amp; Attacks

//While Attacking
if(attacking)
{   
    if(round(image_index) == 2){
        attacking = false;
        sprite_state = 0;
    } else if(round(image_index) == 1){
        gmwSetSwitch(global.Player_Weapon, global.Weapon_Fist, id);
        gmwPostEvent(global.Play_Weapon_Swing, id);
        with instance_create(x, y, obj_attack_hit){
            image_xscale = obj_player.image_xscale;
        }
    }
} 
else if (!talking)
{
    //Ground Check &amp; top-ladder check
    grounded = place_meeting(x, y+1, obj_terrain) || (!climbing_ladder &amp;&amp; !place_meeting(x, y, obj_ladder_top) &amp;&amp; place_meeting(x, y+1, obj_ladder_top));
    
    //Horizontal Input
    move = key_left + key_right;
    hsp = move * movesp;
    
    //Sprite direction
    if(sign(hsp) &lt; 0){
        image_xscale = first_xscale * -1;
    } else if (sign(hsp) &gt; 0){
        image_xscale = first_xscale;
    }
    
    //Gravity
    if(vsp &lt; max_vsp) vsp += grav;
    
    //Jump
    if(grounded &amp;&amp; !grab) {
        vsp = key_jump * -jumpsp;
        if(key_jump) {
            sprite_state = 2;
            gmwPostEvent(global.Play_Footstep, id);
        }
    }
    //horizontal push
    //Detecting grab from left or right side
    if(key_grab &amp;&amp; grab == 0 &amp;&amp; (place_meeting(x+5, y, obj_movable) || place_meeting(x-5, y, obj_movable))){ grab=1;}
    else if(key_grab &amp;&amp; grab == 1 &amp;&amp; (place_meeting(x+5, y, obj_movable) || place_meeting(x-5, y, obj_movable))) {grab=0;}
    
    if(grounded &amp;&amp; grab == 1){
            var block = instance_place(x+5,y,obj_movable);
            if(block == noone) block = instance_place(x-5, y, obj_movable);
            with(block){
            if(!place_meeting(x+obj_player.sprite_width-(18*sign(obj_player.hsp)),y,obj_terrain)){
                    if(place_meeting(x+obj_player.hsp,y,obj_terrain)){
                        while (!place_meeting(x+sign(obj_player.hsp), y, obj_terrain)){
                            x+=sign(obj_player.hsp);
                        }
                        obj_player.hsp = 0;
                    }
                    else if(place_meeting(x+obj_player.hsp,y,obj_enemy)){
                        while (!place_meeting(x+sign(obj_player.hsp), y, obj_enemy)){
                            x+=sign(obj_player.hsp);
                        }
                        obj_player.hsp = 0;
                    }
                    x+=obj_player.hsp/2;
            }
            }
            obj_player.hsp/=2; 
          
    }

    //Ladders
    //Ladder Input
    var inst_ladder;
    inst_ladder = instance_place(x, y, par_ladder);
    var inst_ladder_top;
    inst_ladder_top = instance_place(x, y+1, obj_ladder_top);
    if (key_up || key_down) &amp;&amp; (inst_ladder != noone) {
        climbing_ladder = true;
        x = inst_ladder.x;
    } else if (key_down &amp;&amp; inst_ladder_top != noone){
        climbing_ladder = true;
        x = inst_ladder_top.x;
    }
    //  Ladder Movement
    if(climbing_ladder){
        if(key_jump){
            climbing_ladder = false;
        } else {
            vsp = 0;
            hsp = 0;
            if (key_up) vsp -= 3;
            if (key_down){ 
                vsp += 3;
                if(place_meeting(x, y+vsp, obj_terrain)) climbing_ladder = false;
            }
            if(!(place_meeting(x, y, par_ladder) || place_meeting(x, y+1, obj_ladder_top))) climbing_ladder = false;
        }
    }

    //horizontal collision
    if(place_meeting(x+hsp, y, obj_terrain)){
        while(!place_meeting(x+sign(hsp), y, obj_terrain)){
            x+=sign(hsp);
        }
        hsp = 0;
    }
    x += hsp;
    
    //vertical collision
    if(place_meeting(x, y+vsp, obj_terrain)){
        while(!place_meeting(x, y+sign(vsp), obj_terrain)){
            y+=sign(vsp);
        }
        vsp = 0;
    } else if(!climbing_ladder){
        var inst;
        inst = instance_place(x, y+vsp, obj_ladder_top);
        
        if(inst != noone &amp;&amp;
          (inst.y - inst.sprite_yoffset) &gt; (y + sprite_yoffset) &amp;&amp;
          (inst.y - inst.sprite_yoffset) &lt;= ((y + sprite_yoffset) + vsp)) {
          
            //draw_text(30, 30, (string((inst.y - inst.sprite_yoffset)) + "&gt;" + string(y + sprite_yoffset)));
            while(!place_meeting(x, y+sign(vsp), inst)){
                y+=sign(vsp);
            }
            vsp = 0;
        }
    }
    y += vsp;
    
    //Switching between sprites
    if(hsp == 0 &amp;&amp; vsp == 0){
        sprite_state = 0;
    } else if (vsp &gt; 4) {
        sprite_state = 3;
    } else if(vsp == 0 &amp;&amp; hsp != 0) {
        sprite_state = 1;
    }
    
    //Attack
    if(key_attack &amp;&amp; grounded){
        vsp = 0;
        hsp = 0;
        attacking = true;
        sprite_state = 4;
    }
    //Arrow
    if(mouse_left &amp;&amp; number_of_arrows &gt; 0)
    {
        with  instance_create(x, y, obj_arrow)
        {
            objective_x = mouse_x - obj_player.x;
            objective_y = mouse_y - obj_player.y;
            
            norm = sqrt(objective_x*objective_x + objective_y*objective_y);
            objective_x = objective_x / norm;
            objective_y = objective_y / norm;
            //image_xscale = sign(objective_x);
            //image_yscale = sign(objective_y);
            image_angle = arccos(objective_x)*(180/pi);
            
            if(objective_y &gt; 0){
                image_angle = 360 - image_angle;
            }
            /*
            x = obj_player.x + objective_x;
            y = obj_player.y + objective_y;
        */}
        number_of_arrows--;
        
        gmwSetSwitch(global.Player_Weapon, global.Weapon_Sword, id);
        gmwSetSwitch(global.Surface_Type, global.Surface_Stone, id);
        gmwPostEvent(global.Play_Weapon_Swing, id);
    }
    
    if(key_up &amp; place_meeting(x, y, obj_village_gate))
    {
        //tile_layer_hide(-1);
        //tile_layer_hide(-2);
        var tiles_one = tile_get_ids_at_depth(-1);
        var tiles_two = tile_get_ids_at_depth(-2);
        for (var i = 0; i &lt; array_length_1d(tiles_one); i++;)
        {
            tile_set_alpha(tiles_one[i], 0.5);
        }
         for (var j = 0; j &lt; array_length_1d(tiles_two); j++;)
        {
            tile_set_alpha(tiles_two[j], 0.5);
        }
        tiles_one = 0;
        tiles_two = 0;
        //the values below are specific for the objects that are to be deactivated and activated
        //this is specific fo th entrance of the village REFACTOR THIS TO BE GENERIC
        instance_deactivate_region(2208,384,1,384,true,true);
        instance_activate_region(1696,256,128,512,true);
    }
    
    //doors
    if(key_up &amp; place_meeting(x, y, obj_door_knights_house))
    {
        room_goto(Knights_House);
        obj_player.x = 96;
        obj_player.y = 768;
    }
    
    if(key_up &amp; place_meeting(x, y, obj_door_village))
    {
        room_goto_previous();
    }
    
    //sound
    gmwSet2DPosition(id, x, y, 0, 0);
    if(grounded){
        if(place_meeting(x, y+1, obj_ground_stone))
            gmwSetSwitch(global.Floor, global.Floor_Stone, id);
        else if(place_meeting(x, y+1, obj_ground_grass)){
            gmwSetSwitch(global.Floor, global.Floor_Grass, id);
            //gmwSetSwitch(global.Player_Armor, global.Armor_Chainmail, id);
        }
        else if(place_meeting(x, y+1, obj_ground_wood))
            gmwSetSwitch(global.Floor, global.Floor_Wood, id);
        else
            gmwSetSwitch(global.Floor, global.Floor_Dirt, id);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Changing sprites
//depth = -1;
// sprite_state: 0 - idle | 1 - running | 2 - jumping | 3 - falling | 4 - attacking 
if(last_state != sprite_state){
    switch(sprite_state){
        case 0:
            sprite_index = player_idle;
            break;
        case 1:
            sprite_index = player_running;
            break;
        case 2:
            sprite_index = player_jump;
            break;
        case 3:
            sprite_index = player_falling;
            break;
        case 4:
            sprite_index = player_attack;
            break;
        default:
            //sprite_index = player_idle;
            break;
    }
    image_index = 0;
    image_speed = image_number / room_speed;
}
last_state = sprite_state;

if(sprite_state == 1 &amp;&amp; (image_index==1 || image_index==3))
{
    gmwPostEvent(global.Play_Footstep, id);
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Interaction

//Object interaction

//NPC interaction
if(key_interact &amp;&amp; grounded){
    var instSpeaker;
    var instChest;
    instSpeaker = instance_place(x, y, obj_speaker);
    instChest = instance_place(x, y, obj_chest);
    if (instSpeaker != noone){  //NPC dialog
        with (instSpeaker){
            var instPlayer;
            instPlayer = instance_place(x, y, obj_player);
            dialog_page++;
            if instance_exists(dialog){
                if(dialog_page &gt;= array_length_1d(text)) {
                    dialog_page = -1;
                    change = false;
                    if(instance_exists(obj_npc_test)){
                        with (obj_npc_test){
                            path_speed = 1;
                        }
                    }
                    with (dialog){ 
                        if(instance_exists(obj_dialog_choice)){
                            instPlayer.choosing = false;
                        }
                        instance_destroy();
                    }
                } else if(order[dialog_page] != order[dialog_page-1]){
                    with (dialog){  
                        if(instance_exists(obj_dialog_choice)){
                            instPlayer.choosing = false;
                        }
                        instance_destroy();
                    }
                }
            } else {
                if(instance_exists(obj_npc_test)){
                    with (obj_npc_test){
                        path_speed = 0;
                    }
                }
            }
            if(!instance_exists(dialog) &amp;&amp; change){
                
                change = false;
                AUXxoffset = 0;
                AUXyoffset = 0;
                switch(order[dialog_page]){
                case 0:
                    AUXxoffset = xoffset;
                    AUXyoffset = yoffset;
                    dialog = instance_create(x+AUXxoffset, y+AUXyoffset, obj_dialog);
                    break;
                case 1:
                    AUXxoffset = 16;//-((obj_player.sprite_width*obj_player.image_xscale)/4);
                    AUXyoffset = -57;//-((obj_player.sprite_height*obj_player.image_yscale)/2);
                    dialog = instance_create(instPlayer.x+AUXxoffset, instPlayer.y+AUXyoffset, obj_dialog);
                    break;
                case 2:
                    AUXxoffset = 16;//((instPlayer.sprite_width*0.2)*instPlayer.image_xscale);
                    AUXyoffset = -57;//-((instPlayer.sprite_height*0.4)*instPlayer.image_yscale);
                    instPlayer.choosing = true;
                    dialog = instance_create(instPlayer.x+AUXxoffset, instPlayer.y+AUXyoffset, obj_dialog_choice);
                    break;
                default:
                    break;
                }
            }
            instPlayer.talking = false;
            if(dialog_page != -1) {
                dialog.text = text[dialog_page];
                instPlayer.talking = true;
            }
            change = true;
        }
    } else if (instChest != noone){ //Chest Opening
        with (instChest){
            if(!open){
                open = true;
                sprite_index = chest_open;
            }
        }
    }
} else if (choosing &amp;&amp; (key_up_pressed || key_down_pressed)){
    var inst;
    instSpeaker = instance_place(x, y, obj_speaker);
    if (instSpeaker != noone){  //NPC dialog
        if(key_up_pressed){
            instSpeaker.dialog.choice--;
        } else if(key_down_pressed){
            instSpeaker.dialog.choice++;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_text(5, 15, room_persistent);
var toPrint = string(number_of_arrows) + "xArrow";
if(number_of_arrows != 1){
    toPrint += "s";
}
draw_text(5, 30, toPrint);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
