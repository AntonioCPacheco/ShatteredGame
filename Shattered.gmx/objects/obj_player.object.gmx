<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>Knight_Idle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1000</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>Knight_Idle</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize Variables

if(room == First_Level)
{
    rags = true;
    weapons = false;
}
else if(room == Knights_Village)
{
    rags = false;
    weapons = true;
}

hp = 100;
hearts = 4

grav = 1;
hsp = 0;
vsp = 0;
max_vsp = 15;
jumpsp = 23;
movesp = 10;

triggered_to_interact = false;
triggered_to_attack = false;
triggered_by = noone;

grounded = false;
grab = 0;
choosing = false;
last_choice = -1;
deleteNext = false;

//Variable to check if there is crossbow or not, this variable will be used to know when to shoot arrows or rocks
crossbow = false;
ableArrow = true;
ableArrowCount = 35;
mid_cutscene = false;

sprite_state = 0; //0 - idle | 1 - running | 2 - jumping | 3 - falling
last_state = sprite_state;

iframes = room_speed;
took_damage = 0;
invulnerable = false;

climbing_ladder = false;
attacking = false;
talking = false;

first_xscale = image_xscale;

image_speed = image_number / room_speed;

//number of collectibles you picked
keys = 0;
sewers_key = false;

// this variable is used to check properties when entering or leaving the barracks in the knights village
in_barracks = false;

//this global variable will be used to destroy the arrows that have been thrown if the is more than a certain treshold
MAX_ARROWS = 10;
number_of_arrows = MAX_ARROWS;

gmwRegisterObject(id, "player", global.DEFAULT_GROUP);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Input

key_right = keyboard_check(ord("D"));
key_left = -keyboard_check(ord("A"));
key_up_pressed = keyboard_check_pressed(ord("W"));
key_down_pressed = keyboard_check_pressed(ord("S"));
key_up = keyboard_check(ord("W"));
key_down = keyboard_check(ord("S"));
key_jump = keyboard_check_pressed(vk_space);
key_attack = keyboard_check(ord("F"));
key_interact = keyboard_check_pressed(ord("E"));
key_grab = keyboard_check_pressed(ord("G"));
mouse_left = mouse_check_button_pressed(mb_left);
key_restart = keyboard_check(ord("R"));

if(mid_cutscene){
    key_right = 0;
    key_left = 0;
    key_up_pressed = 0;
    key_down_pressed = 0;
    key_up = 0;
    key_down = 0;
    key_jump = 0;
    key_attack = 0;
    key_interact = 0;
    key_grab = 0;
    mouse_left = 0;
}



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement &amp; Attacks
if(place_meeting(x, y+5, obj_moving_platform_base)){
    var platform = instance_place(x, y+5, obj_moving_platform_base);
    if(platform.behavior == 1){
        if(platform.goingRight) {x+=platform.velocity;}
        else {x-=platform.velocity;}
    }
    else if(platform.behavior == 2){
        if(platform.goingRight) {y+=platform.velocity;}
        else {y-=platform.velocity;}
    }
    else{
        x += cos(platform.angle) * platform.length;
        y += sin(platform.angle) * platform.length;
    }
}
//While Attacking
if(attacking)
{   
    if(round(image_index) == 2){
        attacking = false;
        sprite_state = 0;
    } else if(round(image_index) == 1){
        gmwSetSwitch(global.Player_Weapon, global.Weapon_Fist, id);
        gmwPostEvent(global.Play_Weapon_Swing, id);
        with instance_create(x, y, obj_attack_hit){
            image_xscale = obj_player.image_xscale;
        }
    }
} 
else if (!talking || mid_cutscene)
{
    //Ground Check &amp; top-ladder check
    grounded = place_meeting(x, y+1, obj_terrain) || (!climbing_ladder &amp;&amp; !place_meeting(x, y, obj_ladder_top) &amp;&amp; place_meeting(x, y+1, obj_ladder_top));
    
    //Horizontal Input
    move = key_left + key_right;
    if(!mid_cutscene)
        hsp = move * movesp;
    
    //Sprite direction
    if(sign(hsp) &lt; 0 &amp;&amp; grab==0){
        image_xscale = first_xscale * -1;
    } else if (sign(hsp) &gt; 0 &amp;&amp; grab==0){
        image_xscale = first_xscale;
    }
    
    //Gravity
    if(vsp &lt; max_vsp) vsp += grav;
    
    //Jump
    if(grounded) {
        vsp = key_jump * -jumpsp;
        if(key_jump) {
            grab = 0;
            sprite_state = 2;
            gmwPostEvent(global.Play_Footstep, id);
        }
    }
    
    //---------Boxes-----------
    //horizontal push
    //Detecting grab from left or right side
    if(key_grab){
        if(grab == 0 &amp;&amp; (place_meeting(x+1, y, obj_movable) || place_meeting(x-1, y, obj_movable))){ grab=1;}
        else if(grab == 1 &amp;&amp; (place_meeting(x+1, y, obj_movable) || place_meeting(x-1, y, obj_movable))) {grab=0;}
    }
    
    if(grounded &amp;&amp; grab == 1){
        var block = instance_place(x+1,y,obj_movable);
        if(block == noone) block = instance_place(x-1, y, obj_movable);
        with(block){
            /*if( !(obj_player.x &gt; x &amp;&amp; obj_player.hsp &gt; 0 &amp;&amp; place_meeting(x + sprite_width/2 + 1,y, obj_npc_base)) 
                &amp;&amp; 
                !(obj_player.x &lt; x &amp;&amp; obj_player.hsp &lt; 0 &amp;&amp; place_meeting(x - sprite_width/2 - 1,y,obj_npc_base))){
                if(place_meeting(x+obj_player.hsp,y,obj_npc_base)){
                    while (!place_meeting(x+sign(obj_player.hsp), y, obj_npc_base)){
                        x+=sign(obj_player.hsp);
                        obj_player.x += sign(obj_player.hsp);
                    }
                    obj_player.hsp = 0;
                }
                x+=obj_player.hsp/2;
            }*/
            if( !(obj_player.x &gt; x &amp;&amp; obj_player.hsp &gt; 0 &amp;&amp; place_meeting(x + sprite_width/2 + 1,y,obj_terrain)) 
                &amp;&amp; 
                !(obj_player.x &lt; x &amp;&amp; obj_player.hsp &lt; 0 &amp;&amp; place_meeting(x - sprite_width/2 - 1,y,obj_terrain))){
                if(place_meeting(x+obj_player.hsp,y,obj_terrain)){
                    while (!place_meeting(x+sign(obj_player.hsp), y, obj_terrain)){
                        x+=sign(obj_player.hsp);
                        obj_player.x += sign(obj_player.hsp);
                    }
                    obj_player.hsp = 0;
                }
                x+=obj_player.hsp/2;
            }
        }
        obj_player.hsp/=2; 
    }

    //Ladders
    //Ladder Input
    var inst_ladder;
    inst_ladder = instance_place(x, y, par_ladder);
    var inst_ladder_top;
    inst_ladder_top = instance_place(x, y+1, obj_ladder_top);
    if (key_up || key_down) &amp;&amp; (inst_ladder != noone) {
        climbing_ladder = true;
        x = inst_ladder.x;
    } else if (key_down &amp;&amp; inst_ladder_top != noone){
        climbing_ladder = true;
        x = inst_ladder_top.x;
    }
    //  Ladder Movement
    if(climbing_ladder){
        if(key_jump){
            climbing_ladder = false;
        } else {
            vsp = 0;
            hsp = 0;
            if (key_up) vsp -= 3;
            if (key_down){ 
                vsp += 3;
                if(place_meeting(x, y+vsp, obj_terrain)) climbing_ladder = false;
            }
            if(!(place_meeting(x, y, par_ladder) || place_meeting(x, y+1, obj_ladder_top))) climbing_ladder = false;
        }
    }

    //horizontal collision
    if(place_meeting(x+hsp, y, obj_terrain)){
        while(!place_meeting(x+sign(hsp), y, obj_terrain)){
            x+=sign(hsp);
        }
        hsp = 0;
    }
    x += hsp;
    
    //vertical collision
    if(place_meeting(x, y+vsp, obj_terrain)){
        while(!place_meeting(x, y+sign(vsp), obj_terrain)){
            y+=sign(vsp);
        }
        vsp = 0;
    } else if(!climbing_ladder){
        var inst;
        inst = instance_place(x, y+vsp, obj_ladder_top);
        
        if(inst != noone &amp;&amp;
          (inst.y - inst.sprite_yoffset) &gt; (y + sprite_yoffset) &amp;&amp;
          (inst.y - inst.sprite_yoffset) &lt;= ((y + sprite_yoffset) + vsp)) {
          
            //draw_text(30, 30, (string((inst.y - inst.sprite_yoffset)) + "&gt;" + string(y + sprite_yoffset)));
            while(!place_meeting(x, y+sign(vsp), inst)){
                y+=sign(vsp);
            }
            vsp = 0;
        }
    }
    y += vsp;
    
    //Switching between sprites
    if(grab)
    {
        sprite_state = 9;
    }
    else if(climbing_ladder &amp;&amp; vsp != 0)
    {
        sprite_state = 5;
    }
    else if(hsp == 0 &amp;&amp; vsp == 0){
        sprite_state = 0;
    } else if (vsp &gt; 4) {
        sprite_state = 3;
    } else if(vsp == 0 &amp;&amp; hsp != 0) {
        sprite_state = 1;
    }
    
    //Attack
    if((key_attack || triggered_to_attack) &amp;&amp; grounded){
        triggered_to_attack = false;
        vsp = 0;
        hsp = 0;
        attacking = true;
        sprite_state = 4;
    }
    //Arrow
    if(ableArrowCount &lt; 35) { ableArrowCount++; ableArrow = false;}
    else { ableArrow = true; } 
    if(mouse_left &amp;&amp; number_of_arrows &gt; 0 &amp;&amp; ableArrow)
    {
        with  instance_create(x, y, obj_arrow)
        {
            objective_x = mouse_x - obj_player.x;
            objective_y = mouse_y - obj_player.y;
            
            norm = sqrt(objective_x*objective_x + objective_y*objective_y);
            objective_x = objective_x / norm;
            objective_y = objective_y / norm;
            //image_xscale = sign(objective_x);
            //image_yscale = sign(objective_y);
            image_angle = arccos(objective_x)*(180/pi);
            
            if(objective_y &gt; 0){
                image_angle = 360 - image_angle;
            }
            /*
            x = obj_player.x + objective_x;
            y = obj_player.y + objective_y;
        */}
        number_of_arrows--;
        ableArrowCount = 0;
        
        gmwSetSwitch(global.Player_Weapon, global.Weapon_Crossbow, id);
        gmwSetSwitch(global.Surface_Type, global.Surface_Stone, id);
        gmwPostEvent(global.Play_Weapon_Swing, id);
    }
    
    //sound
    gmwSet2DPosition(id, x, y, 0, 0);
    if(grounded){
        if(place_meeting(x, y+1, obj_ground_stone))
            gmwSetSwitch(global.Floor, global.Floor_Stone, id);
        else if(place_meeting(x, y+1, obj_ground_grass)){
            gmwSetSwitch(global.Floor, global.Floor_Grass, id);
            gmwSetSwitch(global.Player_Armor, global.Armor_Chainmail, id);
        }
        else if(place_meeting(x, y+1, obj_ground_wood))
            gmwSetSwitch(global.Floor, global.Floor_Wood, id);
        else
            gmwSetSwitch(global.Floor, global.Floor_Dirt, id);
    }
}
hsp = 0;

if(took_damage &lt;= iframes){
    took_damage++;
    invulnerable = true;
} else {
    invulnerable = false;
}

if(key_restart)
{
    with(obj_sound_controller)
    {
        instance_destroy();
    }
    game_restart();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Changing sprites
//depth = -1;
// sprite_state: 0 - idle | 1 - running | 2 - jumping | 3 - falling | 4 - attacking 
if(rags)
{
   if(last_state != sprite_state){
            switch(sprite_state){
                case 0:
                    sprite_index = rags_idle;
                    break;
                case 1:
                    sprite_index = rags_running;
                    break;
                case 2:
                    sprite_index = rags_jump;
                    break;
                case 3:
                    sprite_index = rags_falling;
                    break;
                case 4:
                    break;
                case 5:
                    sprite_index = rags_climbing;
                    break;
                case 6:
                    sprite_index = rags_throwing;
                    break;
                case 7:
                    sprite_index = rags_throwing;
                    break;
                case 8:
                    sprite_index = rags_opening_door;
                    break;
                case 9:
                    sprite_index = rags_moving_objects;
                    break;
                default:
                    //sprite_index = player_idle;
                    break;
            }
            image_index = 0;
        }
}
else
{
    if(weapons)
    {
        if(last_state != sprite_state){
            switch(sprite_state){
                case 0:
                    sprite_index = Knight_Idle;
                    break;
                case 1:
                    sprite_index = Knight_Running;
                    break;
                case 2:
                    sprite_index = Knight_Jump;
                    break;
                case 3:
                    sprite_index = Knight_Falling;
                    break;
                case 4:
                    sprite_index = Knight_Attack;
                    break;
                case 5:
                    sprite_index = Knight_climbing;
                    break;
                case 6:
                    sprite_index = Knight_bow_0;
                    break;
                case 7:
                    sprite_index = Knight_bow_45;
                    break;
                case 8:
                    sprite_index = Knight_opening_door;
                    break;
                case 9:
                    sprite_index = Knight_moving_objects;
                    break;
                default:
                    //sprite_index = player_idle;
                    break;
            }
            image_index = 0;
        }   
    }
    else
    {
        if(last_state != sprite_state){
            switch(sprite_state){
                case 0:
                    sprite_index = noWeapon_idle;
                    break;
                case 1:
                    sprite_index = noWeapon_running;
                    break;
                case 2:
                    sprite_index = noWeapon_jump;
                    break;
                case 3:
                    sprite_index = noWeapon_falling;
                    break;
                case 4:
                    break;
                case 5:
                    sprite_index = noWeapon_climbing;
                    break;
                case 6:
                    sprite_index = noWeapon_throwing;
                    break;
                case 7:
                    sprite_index = noWeapon_throwing;
                    break;
                case 8:
                    sprite_index = noWeapon_opening_door;
                    break;
                case 9:
                    sprite_index = noWeapon_moving_objects;
                    break;
                default:
                    //sprite_index = player_idle;
                    break;
            }
            image_index = 0;
        }
    }
}

switch(sprite_state){
    case 0:
    case 1:
    case 2:
    case 3:
    case 5:
    case 8:
    case 9:
        image_speed = image_number * 1.3 / room_speed;
        break;
    default:
        image_speed = 0.05;
        break;
}

ratio = took_damage/room_speed;
if(invulnerable &amp;&amp; ((ratio &gt; 0 &amp;&amp; ratio &lt; .2)||(ratio &gt; .4 &amp;&amp; ratio &lt; .6)||(ratio &gt; .8 &amp;&amp; ratio &lt; 1))){
    image_alpha = 0.4;
} else {
    image_alpha = 1;
}

last_state = sprite_state;
if(sprite_state == 1 &amp;&amp; (image_index==1 || image_index==3))
{
    gmwPostEvent(global.Play_Footstep, id);
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Interaction

//Object interaction

//NPC interaction
if((key_interact || triggered_to_interact) &amp;&amp; grounded){
    sprite_state = 0;
    triggered_to_interact = false;
    var instSpeaker;
    var instChest;
    instSpeaker = instance_place(x, y, obj_speaker);
    if(instSpeaker == noone){
        instSpeaker = triggered_by;
    }
    instChest = instance_place(x, y, obj_chest);
    if (instSpeaker != noone){  //NPC dialog
        with (instSpeaker){
            var instPlayer;
            instPlayer = instance_nearest(x, y, obj_player);
            if instance_exists(dialog){
                if(!dialog.ended &amp;&amp; !instPlayer.mid_cutscene){ //if still writing text
                    dialog.text_count = string_length(dialog.text);
                } else {
                    dialog_page++;
                    if(instPlayer.choosing){
                        with (dialog){ 
                            if(instance_exists(obj_dialog_choice)){ //if dialog was choice
                                instPlayer.choosing = false;
                                instPlayer.last_choice = instance_nearest(x,y, obj_dialog_choice).choice;
                                //BEGIN HACK Change for next delivery
                                if(instPlayer.last_choice == 0){
                                    instSpeaker.dialog_page = -1;
                                    instSpeaker.change = false;
                                } else {
                                    instSpeaker.dialog_page++;
                                }
                            }
                            instance_destroy();
                        }
                    }
                    else if(dialog_page &gt;= array_length_1d(text) || instPlayer.deleteNext) { //if no more dialog
                        deleteNext = false;
                        dialog_page = -1;
                        change = false;
                        if(instance_exists(obj_npc_base)){  //resume npc path
                            with (obj_npc_base){
                                path_speed = 1;
                            }
                        }
                        with (dialog){
                            instance_destroy();
                        }
                    }
                    else if(order[dialog_page] != order[dialog_page-1]){ //if there is still dialog and new dialog is a choice
                        with (dialog){  
                            if(instance_exists(obj_dialog_choice)){
                                instPlayer.choosing = false;
                            }
                            instance_destroy();
                        }
                    }
                    
                }
            } else { //else switch page and stop npc
                dialog_page++;
                if(instance_exists(obj_npc_base)){
                    with (obj_npc_base){
                        path_speed = 0;
                    }
                }
            }
            if(!instance_exists(dialog) &amp;&amp; change){ //create new dialog box for new dialog text
                
                change = false;
                AUXxoffset = 0;
                AUXyoffset = 0;
                switch(order[dialog_page]){
                case 0: //npc text
                    AUXxoffset = xoffset;
                    AUXyoffset = yoffset;
                    dialog = instance_create(x+AUXxoffset, y+AUXyoffset, obj_dialog);
                    dialog.speaker = self;
                    break;
                case 1: //player text
                    AUXxoffset = 16;//-((obj_player.sprite_width*obj_player.image_xscale)/4);
                    AUXyoffset = -57;//-((obj_player.sprite_height*obj_player.image_yscale)/2);
                    dialog = instance_create(instPlayer.x+AUXxoffset, instPlayer.y+AUXyoffset, obj_dialog);
                    dialog.speaker = instPlayer;
                    break;
                case 2: //player choice text
                    AUXxoffset = 16;//((instPlayer.sprite_width*0.2)*instPlayer.image_xscale);
                    AUXyoffset = -57;//-((instPlayer.sprite_height*0.4)*instPlayer.image_yscale);
                    instPlayer.choosing = true;
                    dialog = instance_create(instPlayer.x+AUXxoffset, instPlayer.y+AUXyoffset, obj_dialog_choice);
                    dialog.speaker = instPlayer;
                    break;
                default:
                    break;
                }           
                dialog.xoffset = AUXxoffset;
                dialog.yoffset = AUXyoffset;
            }
            instPlayer.talking = false;
            if(dialog_page != -1) {
                dialog.text = text[dialog_page];
                instPlayer.talking = true;
            }
            if(!instPlayer.talking){
                instPlayer.triggered_by = noone;
            }
            change = true;
        }
    } else if (instChest != noone){ //Chest Opening
        with (instChest){
            if(!open){
                open = true;
                sprite_index = chest_open;
            }
        }
    }
} else if (choosing &amp;&amp; (key_up_pressed || key_down_pressed)){
    var inst;
    instSpeaker = instance_place(x, y, obj_speaker);
    if(instSpeaker == noone){
        instSpeaker = triggered_by;
    }
    if (instSpeaker != noone){  //NPC dialog
        if(key_up_pressed){
            instSpeaker.dialog.choice--;
        } else if(key_down_pressed){
            instSpeaker.dialog.choice++;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_ground_spikes">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(hp &lt;= 0){
    with(obj_sound_controller)
    {
        instance_destroy();
    }
    game_restart();
}
else if(!invulnerable){
    hp -= 25;
    hearts--;
    took_damage = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_attack_enemy_hit">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(hp &lt;= 0){
    with(obj_sound_controller)
    {
        instance_destroy();
    }
    game_restart();
}
else if(!invulnerable){
    hp -= 25;
    hearts--;
    took_damage = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_text(17, 25, room_persistent);
var toPrint = string(number_of_arrows) + "xArrow";
if(number_of_arrows != 1){
    toPrint += "s";
}
draw_text(17, 40, toPrint);

var toPrint = string(keys) + "xKey";
if(keys != 1){
    toPrint += "s";
}
draw_text(17, 55, toPrint);


for( i = 0; i &lt; hearts; i++)
{
    draw_sprite(heart, 0, (55*i)+25, 25);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
